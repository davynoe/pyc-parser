Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COLON

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt_list
Rule 2     stmt_list -> <empty>
Rule 3     stmt_list -> stmt_list statement
Rule 4     statement -> simple_stmt SEMICOLON
Rule 5     statement -> block_stmt
Rule 6     simple_stmt -> expression
Rule 7     simple_stmt -> IDENT ASSIGN expression
Rule 8     simple_stmt -> RETURN expression
Rule 9     simple_stmt -> RETURN
Rule 10    simple_stmt -> PASS
Rule 11    simple_stmt -> PRINT LPAREN arg_list_opt RPAREN
Rule 12    block_stmt -> IF LPAREN expression RPAREN block
Rule 13    block_stmt -> IF LPAREN expression RPAREN block ELSE block
Rule 14    block_stmt -> WHILE LPAREN expression RPAREN block
Rule 15    block_stmt -> FOR LPAREN IDENT IN expression RPAREN block
Rule 16    block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block
Rule 17    param_list_opt -> <empty>
Rule 18    param_list_opt -> param_list
Rule 19    param_list -> IDENT
Rule 20    param_list -> param_list COMMA IDENT
Rule 21    block -> LBRACE stmt_list RBRACE
Rule 22    expression -> or_expr
Rule 23    or_expr -> or_expr OR and_expr
Rule 24    or_expr -> and_expr
Rule 25    and_expr -> and_expr AND not_expr
Rule 26    and_expr -> not_expr
Rule 27    not_expr -> NOT not_expr
Rule 28    not_expr -> comparison
Rule 29    comparison -> arith_expr EQ arith_expr
Rule 30    comparison -> arith_expr NEQ arith_expr
Rule 31    comparison -> arith_expr LT arith_expr
Rule 32    comparison -> arith_expr GT arith_expr
Rule 33    comparison -> arith_expr LE arith_expr
Rule 34    comparison -> arith_expr GE arith_expr
Rule 35    comparison -> arith_expr
Rule 36    arith_expr -> arith_expr PLUS term
Rule 37    arith_expr -> arith_expr MINUS term
Rule 38    arith_expr -> term
Rule 39    term -> term TIMES factor
Rule 40    term -> term DIVIDE factor
Rule 41    term -> term MOD factor
Rule 42    term -> factor
Rule 43    factor -> PLUS factor
Rule 44    factor -> MINUS factor
Rule 45    factor -> atom
Rule 46    atom -> LPAREN expression RPAREN
Rule 47    atom -> INT
Rule 48    atom -> FLOAT
Rule 49    atom -> STRING
Rule 50    atom -> TRUE
Rule 51    atom -> FALSE
Rule 52    atom -> NONE
Rule 53    atom -> IDENT
Rule 54    atom -> IDENT LPAREN arg_list_opt RPAREN
Rule 55    arg_list_opt -> <empty>
Rule 56    arg_list_opt -> arg_list
Rule 57    arg_list -> expression
Rule 58    arg_list -> arg_list COMMA expression
Rule 59    atom -> LBRACKET arg_list_opt RBRACKET

Terminals, with rules where they appear

AND                  : 25
ASSIGN               : 7
COLON                : 
COMMA                : 20 58
DEF                  : 16
DIVIDE               : 40
ELSE                 : 13
EQ                   : 29
FALSE                : 51
FLOAT                : 48
FOR                  : 15
GE                   : 34
GT                   : 32
IDENT                : 7 15 16 19 20 53 54
IF                   : 12 13
IN                   : 15
INT                  : 47
LBRACE               : 21
LBRACKET             : 59
LE                   : 33
LPAREN               : 11 12 13 14 15 16 46 54
LT                   : 31
MINUS                : 37 44
MOD                  : 41
NEQ                  : 30
NONE                 : 52
NOT                  : 27
OR                   : 23
PASS                 : 10
PLUS                 : 36 43
PRINT                : 11
RBRACE               : 21
RBRACKET             : 59
RETURN               : 8 9
RPAREN               : 11 12 13 14 15 16 46 54
SEMICOLON            : 4
STRING               : 49
TIMES                : 39
TRUE                 : 50
WHILE                : 14
error                : 

Nonterminals, with rules where they appear

and_expr             : 23 24 25
arg_list             : 56 58
arg_list_opt         : 11 54 59
arith_expr           : 29 29 30 30 31 31 32 32 33 33 34 34 35 36 37
atom                 : 45
block                : 12 13 13 14 15 16
block_stmt           : 5
comparison           : 28
expression           : 6 7 8 12 13 14 15 46 57 58
factor               : 39 40 41 42 43 44
not_expr             : 25 26 27
or_expr              : 22 23
param_list           : 18 20
param_list_opt       : 16
program              : 0
simple_stmt          : 4
statement            : 3
stmt_list            : 1 3 21
term                 : 36 37 38 39 40 41

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt_list
    (2) stmt_list -> .
    (3) stmt_list -> . stmt_list statement

    IDENT           reduce using rule 2 (stmt_list -> .)
    RETURN          reduce using rule 2 (stmt_list -> .)
    PASS            reduce using rule 2 (stmt_list -> .)
    PRINT           reduce using rule 2 (stmt_list -> .)
    IF              reduce using rule 2 (stmt_list -> .)
    WHILE           reduce using rule 2 (stmt_list -> .)
    FOR             reduce using rule 2 (stmt_list -> .)
    DEF             reduce using rule 2 (stmt_list -> .)
    NOT             reduce using rule 2 (stmt_list -> .)
    PLUS            reduce using rule 2 (stmt_list -> .)
    MINUS           reduce using rule 2 (stmt_list -> .)
    LPAREN          reduce using rule 2 (stmt_list -> .)
    INT             reduce using rule 2 (stmt_list -> .)
    FLOAT           reduce using rule 2 (stmt_list -> .)
    STRING          reduce using rule 2 (stmt_list -> .)
    TRUE            reduce using rule 2 (stmt_list -> .)
    FALSE           reduce using rule 2 (stmt_list -> .)
    NONE            reduce using rule 2 (stmt_list -> .)
    LBRACKET        reduce using rule 2 (stmt_list -> .)
    $end            reduce using rule 2 (stmt_list -> .)

    program                        shift and go to state 1
    stmt_list                      shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> stmt_list .
    (3) stmt_list -> stmt_list . statement
    (4) statement -> . simple_stmt SEMICOLON
    (5) statement -> . block_stmt
    (6) simple_stmt -> . expression
    (7) simple_stmt -> . IDENT ASSIGN expression
    (8) simple_stmt -> . RETURN expression
    (9) simple_stmt -> . RETURN
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . PRINT LPAREN arg_list_opt RPAREN
    (12) block_stmt -> . IF LPAREN expression RPAREN block
    (13) block_stmt -> . IF LPAREN expression RPAREN block ELSE block
    (14) block_stmt -> . WHILE LPAREN expression RPAREN block
    (15) block_stmt -> . FOR LPAREN IDENT IN expression RPAREN block
    (16) block_stmt -> . DEF IDENT LPAREN param_list_opt RPAREN block
    (22) expression -> . or_expr
    (23) or_expr -> . or_expr OR and_expr
    (24) or_expr -> . and_expr
    (25) and_expr -> . and_expr AND not_expr
    (26) and_expr -> . not_expr
    (27) not_expr -> . NOT not_expr
    (28) not_expr -> . comparison
    (29) comparison -> . arith_expr EQ arith_expr
    (30) comparison -> . arith_expr NEQ arith_expr
    (31) comparison -> . arith_expr LT arith_expr
    (32) comparison -> . arith_expr GT arith_expr
    (33) comparison -> . arith_expr LE arith_expr
    (34) comparison -> . arith_expr GE arith_expr
    (35) comparison -> . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    $end            reduce using rule 1 (program -> stmt_list .)
    IDENT           shift and go to state 7
    RETURN          shift and go to state 8
    PASS            shift and go to state 9
    PRINT           shift and go to state 10
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    DEF             shift and go to state 15
    NOT             shift and go to state 19
    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    LBRACKET        shift and go to state 33

    statement                      shift and go to state 3
    simple_stmt                    shift and go to state 4
    block_stmt                     shift and go to state 5
    expression                     shift and go to state 6
    or_expr                        shift and go to state 16
    and_expr                       shift and go to state 17
    not_expr                       shift and go to state 18
    comparison                     shift and go to state 20
    arith_expr                     shift and go to state 21
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 3

    (3) stmt_list -> stmt_list statement .

    IDENT           reduce using rule 3 (stmt_list -> stmt_list statement .)
    RETURN          reduce using rule 3 (stmt_list -> stmt_list statement .)
    PASS            reduce using rule 3 (stmt_list -> stmt_list statement .)
    PRINT           reduce using rule 3 (stmt_list -> stmt_list statement .)
    IF              reduce using rule 3 (stmt_list -> stmt_list statement .)
    WHILE           reduce using rule 3 (stmt_list -> stmt_list statement .)
    FOR             reduce using rule 3 (stmt_list -> stmt_list statement .)
    DEF             reduce using rule 3 (stmt_list -> stmt_list statement .)
    NOT             reduce using rule 3 (stmt_list -> stmt_list statement .)
    PLUS            reduce using rule 3 (stmt_list -> stmt_list statement .)
    MINUS           reduce using rule 3 (stmt_list -> stmt_list statement .)
    LPAREN          reduce using rule 3 (stmt_list -> stmt_list statement .)
    INT             reduce using rule 3 (stmt_list -> stmt_list statement .)
    FLOAT           reduce using rule 3 (stmt_list -> stmt_list statement .)
    STRING          reduce using rule 3 (stmt_list -> stmt_list statement .)
    TRUE            reduce using rule 3 (stmt_list -> stmt_list statement .)
    FALSE           reduce using rule 3 (stmt_list -> stmt_list statement .)
    NONE            reduce using rule 3 (stmt_list -> stmt_list statement .)
    LBRACKET        reduce using rule 3 (stmt_list -> stmt_list statement .)
    $end            reduce using rule 3 (stmt_list -> stmt_list statement .)
    RBRACE          reduce using rule 3 (stmt_list -> stmt_list statement .)


state 4

    (4) statement -> simple_stmt . SEMICOLON

    SEMICOLON       shift and go to state 34


state 5

    (5) statement -> block_stmt .

    IDENT           reduce using rule 5 (statement -> block_stmt .)
    RETURN          reduce using rule 5 (statement -> block_stmt .)
    PASS            reduce using rule 5 (statement -> block_stmt .)
    PRINT           reduce using rule 5 (statement -> block_stmt .)
    IF              reduce using rule 5 (statement -> block_stmt .)
    WHILE           reduce using rule 5 (statement -> block_stmt .)
    FOR             reduce using rule 5 (statement -> block_stmt .)
    DEF             reduce using rule 5 (statement -> block_stmt .)
    NOT             reduce using rule 5 (statement -> block_stmt .)
    PLUS            reduce using rule 5 (statement -> block_stmt .)
    MINUS           reduce using rule 5 (statement -> block_stmt .)
    LPAREN          reduce using rule 5 (statement -> block_stmt .)
    INT             reduce using rule 5 (statement -> block_stmt .)
    FLOAT           reduce using rule 5 (statement -> block_stmt .)
    STRING          reduce using rule 5 (statement -> block_stmt .)
    TRUE            reduce using rule 5 (statement -> block_stmt .)
    FALSE           reduce using rule 5 (statement -> block_stmt .)
    NONE            reduce using rule 5 (statement -> block_stmt .)
    LBRACKET        reduce using rule 5 (statement -> block_stmt .)
    $end            reduce using rule 5 (statement -> block_stmt .)
    RBRACE          reduce using rule 5 (statement -> block_stmt .)


state 6

    (6) simple_stmt -> expression .

    SEMICOLON       reduce using rule 6 (simple_stmt -> expression .)


state 7

    (7) simple_stmt -> IDENT . ASSIGN expression
    (53) atom -> IDENT .
    (54) atom -> IDENT . LPAREN arg_list_opt RPAREN

    ASSIGN          shift and go to state 35
    TIMES           reduce using rule 53 (atom -> IDENT .)
    DIVIDE          reduce using rule 53 (atom -> IDENT .)
    MOD             reduce using rule 53 (atom -> IDENT .)
    EQ              reduce using rule 53 (atom -> IDENT .)
    NEQ             reduce using rule 53 (atom -> IDENT .)
    LT              reduce using rule 53 (atom -> IDENT .)
    GT              reduce using rule 53 (atom -> IDENT .)
    LE              reduce using rule 53 (atom -> IDENT .)
    GE              reduce using rule 53 (atom -> IDENT .)
    PLUS            reduce using rule 53 (atom -> IDENT .)
    MINUS           reduce using rule 53 (atom -> IDENT .)
    AND             reduce using rule 53 (atom -> IDENT .)
    OR              reduce using rule 53 (atom -> IDENT .)
    SEMICOLON       reduce using rule 53 (atom -> IDENT .)
    LPAREN          shift and go to state 36


state 8

    (8) simple_stmt -> RETURN . expression
    (9) simple_stmt -> RETURN .
    (22) expression -> . or_expr
    (23) or_expr -> . or_expr OR and_expr
    (24) or_expr -> . and_expr
    (25) and_expr -> . and_expr AND not_expr
    (26) and_expr -> . not_expr
    (27) not_expr -> . NOT not_expr
    (28) not_expr -> . comparison
    (29) comparison -> . arith_expr EQ arith_expr
    (30) comparison -> . arith_expr NEQ arith_expr
    (31) comparison -> . arith_expr LT arith_expr
    (32) comparison -> . arith_expr GT arith_expr
    (33) comparison -> . arith_expr LE arith_expr
    (34) comparison -> . arith_expr GE arith_expr
    (35) comparison -> . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    SEMICOLON       reduce using rule 9 (simple_stmt -> RETURN .)
    NOT             shift and go to state 19
    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    expression                     shift and go to state 37
    or_expr                        shift and go to state 16
    and_expr                       shift and go to state 17
    not_expr                       shift and go to state 18
    comparison                     shift and go to state 20
    arith_expr                     shift and go to state 21
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 9

    (10) simple_stmt -> PASS .

    SEMICOLON       reduce using rule 10 (simple_stmt -> PASS .)


state 10

    (11) simple_stmt -> PRINT . LPAREN arg_list_opt RPAREN

    LPAREN          shift and go to state 39


state 11

    (46) atom -> LPAREN . expression RPAREN
    (22) expression -> . or_expr
    (23) or_expr -> . or_expr OR and_expr
    (24) or_expr -> . and_expr
    (25) and_expr -> . and_expr AND not_expr
    (26) and_expr -> . not_expr
    (27) not_expr -> . NOT not_expr
    (28) not_expr -> . comparison
    (29) comparison -> . arith_expr EQ arith_expr
    (30) comparison -> . arith_expr NEQ arith_expr
    (31) comparison -> . arith_expr LT arith_expr
    (32) comparison -> . arith_expr GT arith_expr
    (33) comparison -> . arith_expr LE arith_expr
    (34) comparison -> . arith_expr GE arith_expr
    (35) comparison -> . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    NOT             shift and go to state 19
    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    expression                     shift and go to state 40
    or_expr                        shift and go to state 16
    and_expr                       shift and go to state 17
    not_expr                       shift and go to state 18
    comparison                     shift and go to state 20
    arith_expr                     shift and go to state 21
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 12

    (12) block_stmt -> IF . LPAREN expression RPAREN block
    (13) block_stmt -> IF . LPAREN expression RPAREN block ELSE block

    LPAREN          shift and go to state 41


state 13

    (14) block_stmt -> WHILE . LPAREN expression RPAREN block

    LPAREN          shift and go to state 42


state 14

    (15) block_stmt -> FOR . LPAREN IDENT IN expression RPAREN block

    LPAREN          shift and go to state 43


state 15

    (16) block_stmt -> DEF . IDENT LPAREN param_list_opt RPAREN block

    IDENT           shift and go to state 44


state 16

    (22) expression -> or_expr .
    (23) or_expr -> or_expr . OR and_expr

    SEMICOLON       reduce using rule 22 (expression -> or_expr .)
    RPAREN          reduce using rule 22 (expression -> or_expr .)
    COMMA           reduce using rule 22 (expression -> or_expr .)
    RBRACKET        reduce using rule 22 (expression -> or_expr .)
    OR              shift and go to state 45


state 17

    (24) or_expr -> and_expr .
    (25) and_expr -> and_expr . AND not_expr

    OR              reduce using rule 24 (or_expr -> and_expr .)
    SEMICOLON       reduce using rule 24 (or_expr -> and_expr .)
    RPAREN          reduce using rule 24 (or_expr -> and_expr .)
    COMMA           reduce using rule 24 (or_expr -> and_expr .)
    RBRACKET        reduce using rule 24 (or_expr -> and_expr .)
    AND             shift and go to state 46


state 18

    (26) and_expr -> not_expr .

    AND             reduce using rule 26 (and_expr -> not_expr .)
    OR              reduce using rule 26 (and_expr -> not_expr .)
    SEMICOLON       reduce using rule 26 (and_expr -> not_expr .)
    RPAREN          reduce using rule 26 (and_expr -> not_expr .)
    COMMA           reduce using rule 26 (and_expr -> not_expr .)
    RBRACKET        reduce using rule 26 (and_expr -> not_expr .)


state 19

    (27) not_expr -> NOT . not_expr
    (27) not_expr -> . NOT not_expr
    (28) not_expr -> . comparison
    (29) comparison -> . arith_expr EQ arith_expr
    (30) comparison -> . arith_expr NEQ arith_expr
    (31) comparison -> . arith_expr LT arith_expr
    (32) comparison -> . arith_expr GT arith_expr
    (33) comparison -> . arith_expr LE arith_expr
    (34) comparison -> . arith_expr GE arith_expr
    (35) comparison -> . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    NOT             shift and go to state 19
    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    not_expr                       shift and go to state 47
    comparison                     shift and go to state 20
    arith_expr                     shift and go to state 21
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 20

    (28) not_expr -> comparison .

    AND             reduce using rule 28 (not_expr -> comparison .)
    OR              reduce using rule 28 (not_expr -> comparison .)
    SEMICOLON       reduce using rule 28 (not_expr -> comparison .)
    RPAREN          reduce using rule 28 (not_expr -> comparison .)
    COMMA           reduce using rule 28 (not_expr -> comparison .)
    RBRACKET        reduce using rule 28 (not_expr -> comparison .)


state 21

    (29) comparison -> arith_expr . EQ arith_expr
    (30) comparison -> arith_expr . NEQ arith_expr
    (31) comparison -> arith_expr . LT arith_expr
    (32) comparison -> arith_expr . GT arith_expr
    (33) comparison -> arith_expr . LE arith_expr
    (34) comparison -> arith_expr . GE arith_expr
    (35) comparison -> arith_expr .
    (36) arith_expr -> arith_expr . PLUS term
    (37) arith_expr -> arith_expr . MINUS term

    EQ              shift and go to state 48
    NEQ             shift and go to state 49
    LT              shift and go to state 50
    GT              shift and go to state 51
    LE              shift and go to state 52
    GE              shift and go to state 53
    AND             reduce using rule 35 (comparison -> arith_expr .)
    OR              reduce using rule 35 (comparison -> arith_expr .)
    SEMICOLON       reduce using rule 35 (comparison -> arith_expr .)
    RPAREN          reduce using rule 35 (comparison -> arith_expr .)
    COMMA           reduce using rule 35 (comparison -> arith_expr .)
    RBRACKET        reduce using rule 35 (comparison -> arith_expr .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55


state 22

    (43) factor -> PLUS . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    factor                         shift and go to state 56
    atom                           shift and go to state 26

state 23

    (38) arith_expr -> term .
    (39) term -> term . TIMES factor
    (40) term -> term . DIVIDE factor
    (41) term -> term . MOD factor

    EQ              reduce using rule 38 (arith_expr -> term .)
    NEQ             reduce using rule 38 (arith_expr -> term .)
    LT              reduce using rule 38 (arith_expr -> term .)
    GT              reduce using rule 38 (arith_expr -> term .)
    LE              reduce using rule 38 (arith_expr -> term .)
    GE              reduce using rule 38 (arith_expr -> term .)
    PLUS            reduce using rule 38 (arith_expr -> term .)
    MINUS           reduce using rule 38 (arith_expr -> term .)
    AND             reduce using rule 38 (arith_expr -> term .)
    OR              reduce using rule 38 (arith_expr -> term .)
    SEMICOLON       reduce using rule 38 (arith_expr -> term .)
    RPAREN          reduce using rule 38 (arith_expr -> term .)
    COMMA           reduce using rule 38 (arith_expr -> term .)
    RBRACKET        reduce using rule 38 (arith_expr -> term .)
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MOD             shift and go to state 59


state 24

    (44) factor -> MINUS . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    factor                         shift and go to state 60
    atom                           shift and go to state 26

state 25

    (42) term -> factor .

    TIMES           reduce using rule 42 (term -> factor .)
    DIVIDE          reduce using rule 42 (term -> factor .)
    MOD             reduce using rule 42 (term -> factor .)
    EQ              reduce using rule 42 (term -> factor .)
    NEQ             reduce using rule 42 (term -> factor .)
    LT              reduce using rule 42 (term -> factor .)
    GT              reduce using rule 42 (term -> factor .)
    LE              reduce using rule 42 (term -> factor .)
    GE              reduce using rule 42 (term -> factor .)
    PLUS            reduce using rule 42 (term -> factor .)
    MINUS           reduce using rule 42 (term -> factor .)
    AND             reduce using rule 42 (term -> factor .)
    OR              reduce using rule 42 (term -> factor .)
    SEMICOLON       reduce using rule 42 (term -> factor .)
    RPAREN          reduce using rule 42 (term -> factor .)
    COMMA           reduce using rule 42 (term -> factor .)
    RBRACKET        reduce using rule 42 (term -> factor .)


state 26

    (45) factor -> atom .

    TIMES           reduce using rule 45 (factor -> atom .)
    DIVIDE          reduce using rule 45 (factor -> atom .)
    MOD             reduce using rule 45 (factor -> atom .)
    EQ              reduce using rule 45 (factor -> atom .)
    NEQ             reduce using rule 45 (factor -> atom .)
    LT              reduce using rule 45 (factor -> atom .)
    GT              reduce using rule 45 (factor -> atom .)
    LE              reduce using rule 45 (factor -> atom .)
    GE              reduce using rule 45 (factor -> atom .)
    PLUS            reduce using rule 45 (factor -> atom .)
    MINUS           reduce using rule 45 (factor -> atom .)
    AND             reduce using rule 45 (factor -> atom .)
    OR              reduce using rule 45 (factor -> atom .)
    SEMICOLON       reduce using rule 45 (factor -> atom .)
    RPAREN          reduce using rule 45 (factor -> atom .)
    COMMA           reduce using rule 45 (factor -> atom .)
    RBRACKET        reduce using rule 45 (factor -> atom .)


state 27

    (47) atom -> INT .

    TIMES           reduce using rule 47 (atom -> INT .)
    DIVIDE          reduce using rule 47 (atom -> INT .)
    MOD             reduce using rule 47 (atom -> INT .)
    EQ              reduce using rule 47 (atom -> INT .)
    NEQ             reduce using rule 47 (atom -> INT .)
    LT              reduce using rule 47 (atom -> INT .)
    GT              reduce using rule 47 (atom -> INT .)
    LE              reduce using rule 47 (atom -> INT .)
    GE              reduce using rule 47 (atom -> INT .)
    PLUS            reduce using rule 47 (atom -> INT .)
    MINUS           reduce using rule 47 (atom -> INT .)
    AND             reduce using rule 47 (atom -> INT .)
    OR              reduce using rule 47 (atom -> INT .)
    SEMICOLON       reduce using rule 47 (atom -> INT .)
    RPAREN          reduce using rule 47 (atom -> INT .)
    COMMA           reduce using rule 47 (atom -> INT .)
    RBRACKET        reduce using rule 47 (atom -> INT .)


state 28

    (48) atom -> FLOAT .

    TIMES           reduce using rule 48 (atom -> FLOAT .)
    DIVIDE          reduce using rule 48 (atom -> FLOAT .)
    MOD             reduce using rule 48 (atom -> FLOAT .)
    EQ              reduce using rule 48 (atom -> FLOAT .)
    NEQ             reduce using rule 48 (atom -> FLOAT .)
    LT              reduce using rule 48 (atom -> FLOAT .)
    GT              reduce using rule 48 (atom -> FLOAT .)
    LE              reduce using rule 48 (atom -> FLOAT .)
    GE              reduce using rule 48 (atom -> FLOAT .)
    PLUS            reduce using rule 48 (atom -> FLOAT .)
    MINUS           reduce using rule 48 (atom -> FLOAT .)
    AND             reduce using rule 48 (atom -> FLOAT .)
    OR              reduce using rule 48 (atom -> FLOAT .)
    SEMICOLON       reduce using rule 48 (atom -> FLOAT .)
    RPAREN          reduce using rule 48 (atom -> FLOAT .)
    COMMA           reduce using rule 48 (atom -> FLOAT .)
    RBRACKET        reduce using rule 48 (atom -> FLOAT .)


state 29

    (49) atom -> STRING .

    TIMES           reduce using rule 49 (atom -> STRING .)
    DIVIDE          reduce using rule 49 (atom -> STRING .)
    MOD             reduce using rule 49 (atom -> STRING .)
    EQ              reduce using rule 49 (atom -> STRING .)
    NEQ             reduce using rule 49 (atom -> STRING .)
    LT              reduce using rule 49 (atom -> STRING .)
    GT              reduce using rule 49 (atom -> STRING .)
    LE              reduce using rule 49 (atom -> STRING .)
    GE              reduce using rule 49 (atom -> STRING .)
    PLUS            reduce using rule 49 (atom -> STRING .)
    MINUS           reduce using rule 49 (atom -> STRING .)
    AND             reduce using rule 49 (atom -> STRING .)
    OR              reduce using rule 49 (atom -> STRING .)
    SEMICOLON       reduce using rule 49 (atom -> STRING .)
    RPAREN          reduce using rule 49 (atom -> STRING .)
    COMMA           reduce using rule 49 (atom -> STRING .)
    RBRACKET        reduce using rule 49 (atom -> STRING .)


state 30

    (50) atom -> TRUE .

    TIMES           reduce using rule 50 (atom -> TRUE .)
    DIVIDE          reduce using rule 50 (atom -> TRUE .)
    MOD             reduce using rule 50 (atom -> TRUE .)
    EQ              reduce using rule 50 (atom -> TRUE .)
    NEQ             reduce using rule 50 (atom -> TRUE .)
    LT              reduce using rule 50 (atom -> TRUE .)
    GT              reduce using rule 50 (atom -> TRUE .)
    LE              reduce using rule 50 (atom -> TRUE .)
    GE              reduce using rule 50 (atom -> TRUE .)
    PLUS            reduce using rule 50 (atom -> TRUE .)
    MINUS           reduce using rule 50 (atom -> TRUE .)
    AND             reduce using rule 50 (atom -> TRUE .)
    OR              reduce using rule 50 (atom -> TRUE .)
    SEMICOLON       reduce using rule 50 (atom -> TRUE .)
    RPAREN          reduce using rule 50 (atom -> TRUE .)
    COMMA           reduce using rule 50 (atom -> TRUE .)
    RBRACKET        reduce using rule 50 (atom -> TRUE .)


state 31

    (51) atom -> FALSE .

    TIMES           reduce using rule 51 (atom -> FALSE .)
    DIVIDE          reduce using rule 51 (atom -> FALSE .)
    MOD             reduce using rule 51 (atom -> FALSE .)
    EQ              reduce using rule 51 (atom -> FALSE .)
    NEQ             reduce using rule 51 (atom -> FALSE .)
    LT              reduce using rule 51 (atom -> FALSE .)
    GT              reduce using rule 51 (atom -> FALSE .)
    LE              reduce using rule 51 (atom -> FALSE .)
    GE              reduce using rule 51 (atom -> FALSE .)
    PLUS            reduce using rule 51 (atom -> FALSE .)
    MINUS           reduce using rule 51 (atom -> FALSE .)
    AND             reduce using rule 51 (atom -> FALSE .)
    OR              reduce using rule 51 (atom -> FALSE .)
    SEMICOLON       reduce using rule 51 (atom -> FALSE .)
    RPAREN          reduce using rule 51 (atom -> FALSE .)
    COMMA           reduce using rule 51 (atom -> FALSE .)
    RBRACKET        reduce using rule 51 (atom -> FALSE .)


state 32

    (52) atom -> NONE .

    TIMES           reduce using rule 52 (atom -> NONE .)
    DIVIDE          reduce using rule 52 (atom -> NONE .)
    MOD             reduce using rule 52 (atom -> NONE .)
    EQ              reduce using rule 52 (atom -> NONE .)
    NEQ             reduce using rule 52 (atom -> NONE .)
    LT              reduce using rule 52 (atom -> NONE .)
    GT              reduce using rule 52 (atom -> NONE .)
    LE              reduce using rule 52 (atom -> NONE .)
    GE              reduce using rule 52 (atom -> NONE .)
    PLUS            reduce using rule 52 (atom -> NONE .)
    MINUS           reduce using rule 52 (atom -> NONE .)
    AND             reduce using rule 52 (atom -> NONE .)
    OR              reduce using rule 52 (atom -> NONE .)
    SEMICOLON       reduce using rule 52 (atom -> NONE .)
    RPAREN          reduce using rule 52 (atom -> NONE .)
    COMMA           reduce using rule 52 (atom -> NONE .)
    RBRACKET        reduce using rule 52 (atom -> NONE .)


state 33

    (59) atom -> LBRACKET . arg_list_opt RBRACKET
    (55) arg_list_opt -> .
    (56) arg_list_opt -> . arg_list
    (57) arg_list -> . expression
    (58) arg_list -> . arg_list COMMA expression
    (22) expression -> . or_expr
    (23) or_expr -> . or_expr OR and_expr
    (24) or_expr -> . and_expr
    (25) and_expr -> . and_expr AND not_expr
    (26) and_expr -> . not_expr
    (27) not_expr -> . NOT not_expr
    (28) not_expr -> . comparison
    (29) comparison -> . arith_expr EQ arith_expr
    (30) comparison -> . arith_expr NEQ arith_expr
    (31) comparison -> . arith_expr LT arith_expr
    (32) comparison -> . arith_expr GT arith_expr
    (33) comparison -> . arith_expr LE arith_expr
    (34) comparison -> . arith_expr GE arith_expr
    (35) comparison -> . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    RBRACKET        reduce using rule 55 (arg_list_opt -> .)
    NOT             shift and go to state 19
    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    arg_list_opt                   shift and go to state 61
    arg_list                       shift and go to state 62
    expression                     shift and go to state 63
    or_expr                        shift and go to state 16
    and_expr                       shift and go to state 17
    not_expr                       shift and go to state 18
    comparison                     shift and go to state 20
    arith_expr                     shift and go to state 21
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 34

    (4) statement -> simple_stmt SEMICOLON .

    IDENT           reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    RETURN          reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    PASS            reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    PRINT           reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    IF              reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    WHILE           reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    FOR             reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    DEF             reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    NOT             reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    PLUS            reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    MINUS           reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    LPAREN          reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    INT             reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    FLOAT           reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    STRING          reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    TRUE            reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    FALSE           reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    NONE            reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    LBRACKET        reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    $end            reduce using rule 4 (statement -> simple_stmt SEMICOLON .)
    RBRACE          reduce using rule 4 (statement -> simple_stmt SEMICOLON .)


state 35

    (7) simple_stmt -> IDENT ASSIGN . expression
    (22) expression -> . or_expr
    (23) or_expr -> . or_expr OR and_expr
    (24) or_expr -> . and_expr
    (25) and_expr -> . and_expr AND not_expr
    (26) and_expr -> . not_expr
    (27) not_expr -> . NOT not_expr
    (28) not_expr -> . comparison
    (29) comparison -> . arith_expr EQ arith_expr
    (30) comparison -> . arith_expr NEQ arith_expr
    (31) comparison -> . arith_expr LT arith_expr
    (32) comparison -> . arith_expr GT arith_expr
    (33) comparison -> . arith_expr LE arith_expr
    (34) comparison -> . arith_expr GE arith_expr
    (35) comparison -> . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    NOT             shift and go to state 19
    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    expression                     shift and go to state 64
    or_expr                        shift and go to state 16
    and_expr                       shift and go to state 17
    not_expr                       shift and go to state 18
    comparison                     shift and go to state 20
    arith_expr                     shift and go to state 21
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 36

    (54) atom -> IDENT LPAREN . arg_list_opt RPAREN
    (55) arg_list_opt -> .
    (56) arg_list_opt -> . arg_list
    (57) arg_list -> . expression
    (58) arg_list -> . arg_list COMMA expression
    (22) expression -> . or_expr
    (23) or_expr -> . or_expr OR and_expr
    (24) or_expr -> . and_expr
    (25) and_expr -> . and_expr AND not_expr
    (26) and_expr -> . not_expr
    (27) not_expr -> . NOT not_expr
    (28) not_expr -> . comparison
    (29) comparison -> . arith_expr EQ arith_expr
    (30) comparison -> . arith_expr NEQ arith_expr
    (31) comparison -> . arith_expr LT arith_expr
    (32) comparison -> . arith_expr GT arith_expr
    (33) comparison -> . arith_expr LE arith_expr
    (34) comparison -> . arith_expr GE arith_expr
    (35) comparison -> . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    RPAREN          reduce using rule 55 (arg_list_opt -> .)
    NOT             shift and go to state 19
    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    arg_list_opt                   shift and go to state 65
    arg_list                       shift and go to state 62
    expression                     shift and go to state 63
    or_expr                        shift and go to state 16
    and_expr                       shift and go to state 17
    not_expr                       shift and go to state 18
    comparison                     shift and go to state 20
    arith_expr                     shift and go to state 21
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 37

    (8) simple_stmt -> RETURN expression .

    SEMICOLON       reduce using rule 8 (simple_stmt -> RETURN expression .)


state 38

    (53) atom -> IDENT .
    (54) atom -> IDENT . LPAREN arg_list_opt RPAREN

    TIMES           reduce using rule 53 (atom -> IDENT .)
    DIVIDE          reduce using rule 53 (atom -> IDENT .)
    MOD             reduce using rule 53 (atom -> IDENT .)
    EQ              reduce using rule 53 (atom -> IDENT .)
    NEQ             reduce using rule 53 (atom -> IDENT .)
    LT              reduce using rule 53 (atom -> IDENT .)
    GT              reduce using rule 53 (atom -> IDENT .)
    LE              reduce using rule 53 (atom -> IDENT .)
    GE              reduce using rule 53 (atom -> IDENT .)
    PLUS            reduce using rule 53 (atom -> IDENT .)
    MINUS           reduce using rule 53 (atom -> IDENT .)
    AND             reduce using rule 53 (atom -> IDENT .)
    OR              reduce using rule 53 (atom -> IDENT .)
    SEMICOLON       reduce using rule 53 (atom -> IDENT .)
    RPAREN          reduce using rule 53 (atom -> IDENT .)
    COMMA           reduce using rule 53 (atom -> IDENT .)
    RBRACKET        reduce using rule 53 (atom -> IDENT .)
    LPAREN          shift and go to state 36


state 39

    (11) simple_stmt -> PRINT LPAREN . arg_list_opt RPAREN
    (55) arg_list_opt -> .
    (56) arg_list_opt -> . arg_list
    (57) arg_list -> . expression
    (58) arg_list -> . arg_list COMMA expression
    (22) expression -> . or_expr
    (23) or_expr -> . or_expr OR and_expr
    (24) or_expr -> . and_expr
    (25) and_expr -> . and_expr AND not_expr
    (26) and_expr -> . not_expr
    (27) not_expr -> . NOT not_expr
    (28) not_expr -> . comparison
    (29) comparison -> . arith_expr EQ arith_expr
    (30) comparison -> . arith_expr NEQ arith_expr
    (31) comparison -> . arith_expr LT arith_expr
    (32) comparison -> . arith_expr GT arith_expr
    (33) comparison -> . arith_expr LE arith_expr
    (34) comparison -> . arith_expr GE arith_expr
    (35) comparison -> . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    RPAREN          reduce using rule 55 (arg_list_opt -> .)
    NOT             shift and go to state 19
    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    arg_list_opt                   shift and go to state 66
    arg_list                       shift and go to state 62
    expression                     shift and go to state 63
    or_expr                        shift and go to state 16
    and_expr                       shift and go to state 17
    not_expr                       shift and go to state 18
    comparison                     shift and go to state 20
    arith_expr                     shift and go to state 21
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 40

    (46) atom -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 67


state 41

    (12) block_stmt -> IF LPAREN . expression RPAREN block
    (13) block_stmt -> IF LPAREN . expression RPAREN block ELSE block
    (22) expression -> . or_expr
    (23) or_expr -> . or_expr OR and_expr
    (24) or_expr -> . and_expr
    (25) and_expr -> . and_expr AND not_expr
    (26) and_expr -> . not_expr
    (27) not_expr -> . NOT not_expr
    (28) not_expr -> . comparison
    (29) comparison -> . arith_expr EQ arith_expr
    (30) comparison -> . arith_expr NEQ arith_expr
    (31) comparison -> . arith_expr LT arith_expr
    (32) comparison -> . arith_expr GT arith_expr
    (33) comparison -> . arith_expr LE arith_expr
    (34) comparison -> . arith_expr GE arith_expr
    (35) comparison -> . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    NOT             shift and go to state 19
    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    expression                     shift and go to state 68
    or_expr                        shift and go to state 16
    and_expr                       shift and go to state 17
    not_expr                       shift and go to state 18
    comparison                     shift and go to state 20
    arith_expr                     shift and go to state 21
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 42

    (14) block_stmt -> WHILE LPAREN . expression RPAREN block
    (22) expression -> . or_expr
    (23) or_expr -> . or_expr OR and_expr
    (24) or_expr -> . and_expr
    (25) and_expr -> . and_expr AND not_expr
    (26) and_expr -> . not_expr
    (27) not_expr -> . NOT not_expr
    (28) not_expr -> . comparison
    (29) comparison -> . arith_expr EQ arith_expr
    (30) comparison -> . arith_expr NEQ arith_expr
    (31) comparison -> . arith_expr LT arith_expr
    (32) comparison -> . arith_expr GT arith_expr
    (33) comparison -> . arith_expr LE arith_expr
    (34) comparison -> . arith_expr GE arith_expr
    (35) comparison -> . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    NOT             shift and go to state 19
    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    expression                     shift and go to state 69
    or_expr                        shift and go to state 16
    and_expr                       shift and go to state 17
    not_expr                       shift and go to state 18
    comparison                     shift and go to state 20
    arith_expr                     shift and go to state 21
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 43

    (15) block_stmt -> FOR LPAREN . IDENT IN expression RPAREN block

    IDENT           shift and go to state 70


state 44

    (16) block_stmt -> DEF IDENT . LPAREN param_list_opt RPAREN block

    LPAREN          shift and go to state 71


state 45

    (23) or_expr -> or_expr OR . and_expr
    (25) and_expr -> . and_expr AND not_expr
    (26) and_expr -> . not_expr
    (27) not_expr -> . NOT not_expr
    (28) not_expr -> . comparison
    (29) comparison -> . arith_expr EQ arith_expr
    (30) comparison -> . arith_expr NEQ arith_expr
    (31) comparison -> . arith_expr LT arith_expr
    (32) comparison -> . arith_expr GT arith_expr
    (33) comparison -> . arith_expr LE arith_expr
    (34) comparison -> . arith_expr GE arith_expr
    (35) comparison -> . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    NOT             shift and go to state 19
    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    and_expr                       shift and go to state 72
    not_expr                       shift and go to state 18
    comparison                     shift and go to state 20
    arith_expr                     shift and go to state 21
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 46

    (25) and_expr -> and_expr AND . not_expr
    (27) not_expr -> . NOT not_expr
    (28) not_expr -> . comparison
    (29) comparison -> . arith_expr EQ arith_expr
    (30) comparison -> . arith_expr NEQ arith_expr
    (31) comparison -> . arith_expr LT arith_expr
    (32) comparison -> . arith_expr GT arith_expr
    (33) comparison -> . arith_expr LE arith_expr
    (34) comparison -> . arith_expr GE arith_expr
    (35) comparison -> . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    NOT             shift and go to state 19
    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    not_expr                       shift and go to state 73
    comparison                     shift and go to state 20
    arith_expr                     shift and go to state 21
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 47

    (27) not_expr -> NOT not_expr .

    AND             reduce using rule 27 (not_expr -> NOT not_expr .)
    OR              reduce using rule 27 (not_expr -> NOT not_expr .)
    SEMICOLON       reduce using rule 27 (not_expr -> NOT not_expr .)
    RPAREN          reduce using rule 27 (not_expr -> NOT not_expr .)
    COMMA           reduce using rule 27 (not_expr -> NOT not_expr .)
    RBRACKET        reduce using rule 27 (not_expr -> NOT not_expr .)


state 48

    (29) comparison -> arith_expr EQ . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    arith_expr                     shift and go to state 74
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 49

    (30) comparison -> arith_expr NEQ . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    arith_expr                     shift and go to state 75
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 50

    (31) comparison -> arith_expr LT . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    arith_expr                     shift and go to state 76
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 51

    (32) comparison -> arith_expr GT . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    arith_expr                     shift and go to state 77
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 52

    (33) comparison -> arith_expr LE . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    arith_expr                     shift and go to state 78
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 53

    (34) comparison -> arith_expr GE . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    arith_expr                     shift and go to state 79
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 54

    (36) arith_expr -> arith_expr PLUS . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    term                           shift and go to state 80
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 55

    (37) arith_expr -> arith_expr MINUS . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    term                           shift and go to state 81
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 56

    (43) factor -> PLUS factor .

    TIMES           reduce using rule 43 (factor -> PLUS factor .)
    DIVIDE          reduce using rule 43 (factor -> PLUS factor .)
    MOD             reduce using rule 43 (factor -> PLUS factor .)
    EQ              reduce using rule 43 (factor -> PLUS factor .)
    NEQ             reduce using rule 43 (factor -> PLUS factor .)
    LT              reduce using rule 43 (factor -> PLUS factor .)
    GT              reduce using rule 43 (factor -> PLUS factor .)
    LE              reduce using rule 43 (factor -> PLUS factor .)
    GE              reduce using rule 43 (factor -> PLUS factor .)
    PLUS            reduce using rule 43 (factor -> PLUS factor .)
    MINUS           reduce using rule 43 (factor -> PLUS factor .)
    AND             reduce using rule 43 (factor -> PLUS factor .)
    OR              reduce using rule 43 (factor -> PLUS factor .)
    SEMICOLON       reduce using rule 43 (factor -> PLUS factor .)
    RPAREN          reduce using rule 43 (factor -> PLUS factor .)
    COMMA           reduce using rule 43 (factor -> PLUS factor .)
    RBRACKET        reduce using rule 43 (factor -> PLUS factor .)


state 57

    (39) term -> term TIMES . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    factor                         shift and go to state 82
    atom                           shift and go to state 26

state 58

    (40) term -> term DIVIDE . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    factor                         shift and go to state 83
    atom                           shift and go to state 26

state 59

    (41) term -> term MOD . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    factor                         shift and go to state 84
    atom                           shift and go to state 26

state 60

    (44) factor -> MINUS factor .

    TIMES           reduce using rule 44 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 44 (factor -> MINUS factor .)
    MOD             reduce using rule 44 (factor -> MINUS factor .)
    EQ              reduce using rule 44 (factor -> MINUS factor .)
    NEQ             reduce using rule 44 (factor -> MINUS factor .)
    LT              reduce using rule 44 (factor -> MINUS factor .)
    GT              reduce using rule 44 (factor -> MINUS factor .)
    LE              reduce using rule 44 (factor -> MINUS factor .)
    GE              reduce using rule 44 (factor -> MINUS factor .)
    PLUS            reduce using rule 44 (factor -> MINUS factor .)
    MINUS           reduce using rule 44 (factor -> MINUS factor .)
    AND             reduce using rule 44 (factor -> MINUS factor .)
    OR              reduce using rule 44 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 44 (factor -> MINUS factor .)
    RPAREN          reduce using rule 44 (factor -> MINUS factor .)
    COMMA           reduce using rule 44 (factor -> MINUS factor .)
    RBRACKET        reduce using rule 44 (factor -> MINUS factor .)


state 61

    (59) atom -> LBRACKET arg_list_opt . RBRACKET

    RBRACKET        shift and go to state 85


state 62

    (56) arg_list_opt -> arg_list .
    (58) arg_list -> arg_list . COMMA expression

    RBRACKET        reduce using rule 56 (arg_list_opt -> arg_list .)
    RPAREN          reduce using rule 56 (arg_list_opt -> arg_list .)
    COMMA           shift and go to state 86


state 63

    (57) arg_list -> expression .

    COMMA           reduce using rule 57 (arg_list -> expression .)
    RBRACKET        reduce using rule 57 (arg_list -> expression .)
    RPAREN          reduce using rule 57 (arg_list -> expression .)


state 64

    (7) simple_stmt -> IDENT ASSIGN expression .

    SEMICOLON       reduce using rule 7 (simple_stmt -> IDENT ASSIGN expression .)


state 65

    (54) atom -> IDENT LPAREN arg_list_opt . RPAREN

    RPAREN          shift and go to state 87


state 66

    (11) simple_stmt -> PRINT LPAREN arg_list_opt . RPAREN

    RPAREN          shift and go to state 88


state 67

    (46) atom -> LPAREN expression RPAREN .

    TIMES           reduce using rule 46 (atom -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 46 (atom -> LPAREN expression RPAREN .)
    MOD             reduce using rule 46 (atom -> LPAREN expression RPAREN .)
    EQ              reduce using rule 46 (atom -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 46 (atom -> LPAREN expression RPAREN .)
    LT              reduce using rule 46 (atom -> LPAREN expression RPAREN .)
    GT              reduce using rule 46 (atom -> LPAREN expression RPAREN .)
    LE              reduce using rule 46 (atom -> LPAREN expression RPAREN .)
    GE              reduce using rule 46 (atom -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 46 (atom -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 46 (atom -> LPAREN expression RPAREN .)
    AND             reduce using rule 46 (atom -> LPAREN expression RPAREN .)
    OR              reduce using rule 46 (atom -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 46 (atom -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 46 (atom -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 46 (atom -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 46 (atom -> LPAREN expression RPAREN .)


state 68

    (12) block_stmt -> IF LPAREN expression . RPAREN block
    (13) block_stmt -> IF LPAREN expression . RPAREN block ELSE block

    RPAREN          shift and go to state 89


state 69

    (14) block_stmt -> WHILE LPAREN expression . RPAREN block

    RPAREN          shift and go to state 90


state 70

    (15) block_stmt -> FOR LPAREN IDENT . IN expression RPAREN block

    IN              shift and go to state 91


state 71

    (16) block_stmt -> DEF IDENT LPAREN . param_list_opt RPAREN block
    (17) param_list_opt -> .
    (18) param_list_opt -> . param_list
    (19) param_list -> . IDENT
    (20) param_list -> . param_list COMMA IDENT

    RPAREN          reduce using rule 17 (param_list_opt -> .)
    IDENT           shift and go to state 92

    param_list_opt                 shift and go to state 93
    param_list                     shift and go to state 94

state 72

    (23) or_expr -> or_expr OR and_expr .
    (25) and_expr -> and_expr . AND not_expr

    OR              reduce using rule 23 (or_expr -> or_expr OR and_expr .)
    SEMICOLON       reduce using rule 23 (or_expr -> or_expr OR and_expr .)
    RPAREN          reduce using rule 23 (or_expr -> or_expr OR and_expr .)
    COMMA           reduce using rule 23 (or_expr -> or_expr OR and_expr .)
    RBRACKET        reduce using rule 23 (or_expr -> or_expr OR and_expr .)
    AND             shift and go to state 46


state 73

    (25) and_expr -> and_expr AND not_expr .

    AND             reduce using rule 25 (and_expr -> and_expr AND not_expr .)
    OR              reduce using rule 25 (and_expr -> and_expr AND not_expr .)
    SEMICOLON       reduce using rule 25 (and_expr -> and_expr AND not_expr .)
    RPAREN          reduce using rule 25 (and_expr -> and_expr AND not_expr .)
    COMMA           reduce using rule 25 (and_expr -> and_expr AND not_expr .)
    RBRACKET        reduce using rule 25 (and_expr -> and_expr AND not_expr .)


state 74

    (29) comparison -> arith_expr EQ arith_expr .
    (36) arith_expr -> arith_expr . PLUS term
    (37) arith_expr -> arith_expr . MINUS term

    AND             reduce using rule 29 (comparison -> arith_expr EQ arith_expr .)
    OR              reduce using rule 29 (comparison -> arith_expr EQ arith_expr .)
    SEMICOLON       reduce using rule 29 (comparison -> arith_expr EQ arith_expr .)
    RPAREN          reduce using rule 29 (comparison -> arith_expr EQ arith_expr .)
    COMMA           reduce using rule 29 (comparison -> arith_expr EQ arith_expr .)
    RBRACKET        reduce using rule 29 (comparison -> arith_expr EQ arith_expr .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55


state 75

    (30) comparison -> arith_expr NEQ arith_expr .
    (36) arith_expr -> arith_expr . PLUS term
    (37) arith_expr -> arith_expr . MINUS term

    AND             reduce using rule 30 (comparison -> arith_expr NEQ arith_expr .)
    OR              reduce using rule 30 (comparison -> arith_expr NEQ arith_expr .)
    SEMICOLON       reduce using rule 30 (comparison -> arith_expr NEQ arith_expr .)
    RPAREN          reduce using rule 30 (comparison -> arith_expr NEQ arith_expr .)
    COMMA           reduce using rule 30 (comparison -> arith_expr NEQ arith_expr .)
    RBRACKET        reduce using rule 30 (comparison -> arith_expr NEQ arith_expr .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55


state 76

    (31) comparison -> arith_expr LT arith_expr .
    (36) arith_expr -> arith_expr . PLUS term
    (37) arith_expr -> arith_expr . MINUS term

    AND             reduce using rule 31 (comparison -> arith_expr LT arith_expr .)
    OR              reduce using rule 31 (comparison -> arith_expr LT arith_expr .)
    SEMICOLON       reduce using rule 31 (comparison -> arith_expr LT arith_expr .)
    RPAREN          reduce using rule 31 (comparison -> arith_expr LT arith_expr .)
    COMMA           reduce using rule 31 (comparison -> arith_expr LT arith_expr .)
    RBRACKET        reduce using rule 31 (comparison -> arith_expr LT arith_expr .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55


state 77

    (32) comparison -> arith_expr GT arith_expr .
    (36) arith_expr -> arith_expr . PLUS term
    (37) arith_expr -> arith_expr . MINUS term

    AND             reduce using rule 32 (comparison -> arith_expr GT arith_expr .)
    OR              reduce using rule 32 (comparison -> arith_expr GT arith_expr .)
    SEMICOLON       reduce using rule 32 (comparison -> arith_expr GT arith_expr .)
    RPAREN          reduce using rule 32 (comparison -> arith_expr GT arith_expr .)
    COMMA           reduce using rule 32 (comparison -> arith_expr GT arith_expr .)
    RBRACKET        reduce using rule 32 (comparison -> arith_expr GT arith_expr .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55


state 78

    (33) comparison -> arith_expr LE arith_expr .
    (36) arith_expr -> arith_expr . PLUS term
    (37) arith_expr -> arith_expr . MINUS term

    AND             reduce using rule 33 (comparison -> arith_expr LE arith_expr .)
    OR              reduce using rule 33 (comparison -> arith_expr LE arith_expr .)
    SEMICOLON       reduce using rule 33 (comparison -> arith_expr LE arith_expr .)
    RPAREN          reduce using rule 33 (comparison -> arith_expr LE arith_expr .)
    COMMA           reduce using rule 33 (comparison -> arith_expr LE arith_expr .)
    RBRACKET        reduce using rule 33 (comparison -> arith_expr LE arith_expr .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55


state 79

    (34) comparison -> arith_expr GE arith_expr .
    (36) arith_expr -> arith_expr . PLUS term
    (37) arith_expr -> arith_expr . MINUS term

    AND             reduce using rule 34 (comparison -> arith_expr GE arith_expr .)
    OR              reduce using rule 34 (comparison -> arith_expr GE arith_expr .)
    SEMICOLON       reduce using rule 34 (comparison -> arith_expr GE arith_expr .)
    RPAREN          reduce using rule 34 (comparison -> arith_expr GE arith_expr .)
    COMMA           reduce using rule 34 (comparison -> arith_expr GE arith_expr .)
    RBRACKET        reduce using rule 34 (comparison -> arith_expr GE arith_expr .)
    PLUS            shift and go to state 54
    MINUS           shift and go to state 55


state 80

    (36) arith_expr -> arith_expr PLUS term .
    (39) term -> term . TIMES factor
    (40) term -> term . DIVIDE factor
    (41) term -> term . MOD factor

    EQ              reduce using rule 36 (arith_expr -> arith_expr PLUS term .)
    NEQ             reduce using rule 36 (arith_expr -> arith_expr PLUS term .)
    LT              reduce using rule 36 (arith_expr -> arith_expr PLUS term .)
    GT              reduce using rule 36 (arith_expr -> arith_expr PLUS term .)
    LE              reduce using rule 36 (arith_expr -> arith_expr PLUS term .)
    GE              reduce using rule 36 (arith_expr -> arith_expr PLUS term .)
    PLUS            reduce using rule 36 (arith_expr -> arith_expr PLUS term .)
    MINUS           reduce using rule 36 (arith_expr -> arith_expr PLUS term .)
    AND             reduce using rule 36 (arith_expr -> arith_expr PLUS term .)
    OR              reduce using rule 36 (arith_expr -> arith_expr PLUS term .)
    SEMICOLON       reduce using rule 36 (arith_expr -> arith_expr PLUS term .)
    RPAREN          reduce using rule 36 (arith_expr -> arith_expr PLUS term .)
    COMMA           reduce using rule 36 (arith_expr -> arith_expr PLUS term .)
    RBRACKET        reduce using rule 36 (arith_expr -> arith_expr PLUS term .)
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MOD             shift and go to state 59


state 81

    (37) arith_expr -> arith_expr MINUS term .
    (39) term -> term . TIMES factor
    (40) term -> term . DIVIDE factor
    (41) term -> term . MOD factor

    EQ              reduce using rule 37 (arith_expr -> arith_expr MINUS term .)
    NEQ             reduce using rule 37 (arith_expr -> arith_expr MINUS term .)
    LT              reduce using rule 37 (arith_expr -> arith_expr MINUS term .)
    GT              reduce using rule 37 (arith_expr -> arith_expr MINUS term .)
    LE              reduce using rule 37 (arith_expr -> arith_expr MINUS term .)
    GE              reduce using rule 37 (arith_expr -> arith_expr MINUS term .)
    PLUS            reduce using rule 37 (arith_expr -> arith_expr MINUS term .)
    MINUS           reduce using rule 37 (arith_expr -> arith_expr MINUS term .)
    AND             reduce using rule 37 (arith_expr -> arith_expr MINUS term .)
    OR              reduce using rule 37 (arith_expr -> arith_expr MINUS term .)
    SEMICOLON       reduce using rule 37 (arith_expr -> arith_expr MINUS term .)
    RPAREN          reduce using rule 37 (arith_expr -> arith_expr MINUS term .)
    COMMA           reduce using rule 37 (arith_expr -> arith_expr MINUS term .)
    RBRACKET        reduce using rule 37 (arith_expr -> arith_expr MINUS term .)
    TIMES           shift and go to state 57
    DIVIDE          shift and go to state 58
    MOD             shift and go to state 59


state 82

    (39) term -> term TIMES factor .

    TIMES           reduce using rule 39 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 39 (term -> term TIMES factor .)
    MOD             reduce using rule 39 (term -> term TIMES factor .)
    EQ              reduce using rule 39 (term -> term TIMES factor .)
    NEQ             reduce using rule 39 (term -> term TIMES factor .)
    LT              reduce using rule 39 (term -> term TIMES factor .)
    GT              reduce using rule 39 (term -> term TIMES factor .)
    LE              reduce using rule 39 (term -> term TIMES factor .)
    GE              reduce using rule 39 (term -> term TIMES factor .)
    PLUS            reduce using rule 39 (term -> term TIMES factor .)
    MINUS           reduce using rule 39 (term -> term TIMES factor .)
    AND             reduce using rule 39 (term -> term TIMES factor .)
    OR              reduce using rule 39 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 39 (term -> term TIMES factor .)
    RPAREN          reduce using rule 39 (term -> term TIMES factor .)
    COMMA           reduce using rule 39 (term -> term TIMES factor .)
    RBRACKET        reduce using rule 39 (term -> term TIMES factor .)


state 83

    (40) term -> term DIVIDE factor .

    TIMES           reduce using rule 40 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 40 (term -> term DIVIDE factor .)
    MOD             reduce using rule 40 (term -> term DIVIDE factor .)
    EQ              reduce using rule 40 (term -> term DIVIDE factor .)
    NEQ             reduce using rule 40 (term -> term DIVIDE factor .)
    LT              reduce using rule 40 (term -> term DIVIDE factor .)
    GT              reduce using rule 40 (term -> term DIVIDE factor .)
    LE              reduce using rule 40 (term -> term DIVIDE factor .)
    GE              reduce using rule 40 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 40 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 40 (term -> term DIVIDE factor .)
    AND             reduce using rule 40 (term -> term DIVIDE factor .)
    OR              reduce using rule 40 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 40 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 40 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 40 (term -> term DIVIDE factor .)
    RBRACKET        reduce using rule 40 (term -> term DIVIDE factor .)


state 84

    (41) term -> term MOD factor .

    TIMES           reduce using rule 41 (term -> term MOD factor .)
    DIVIDE          reduce using rule 41 (term -> term MOD factor .)
    MOD             reduce using rule 41 (term -> term MOD factor .)
    EQ              reduce using rule 41 (term -> term MOD factor .)
    NEQ             reduce using rule 41 (term -> term MOD factor .)
    LT              reduce using rule 41 (term -> term MOD factor .)
    GT              reduce using rule 41 (term -> term MOD factor .)
    LE              reduce using rule 41 (term -> term MOD factor .)
    GE              reduce using rule 41 (term -> term MOD factor .)
    PLUS            reduce using rule 41 (term -> term MOD factor .)
    MINUS           reduce using rule 41 (term -> term MOD factor .)
    AND             reduce using rule 41 (term -> term MOD factor .)
    OR              reduce using rule 41 (term -> term MOD factor .)
    SEMICOLON       reduce using rule 41 (term -> term MOD factor .)
    RPAREN          reduce using rule 41 (term -> term MOD factor .)
    COMMA           reduce using rule 41 (term -> term MOD factor .)
    RBRACKET        reduce using rule 41 (term -> term MOD factor .)


state 85

    (59) atom -> LBRACKET arg_list_opt RBRACKET .

    TIMES           reduce using rule 59 (atom -> LBRACKET arg_list_opt RBRACKET .)
    DIVIDE          reduce using rule 59 (atom -> LBRACKET arg_list_opt RBRACKET .)
    MOD             reduce using rule 59 (atom -> LBRACKET arg_list_opt RBRACKET .)
    EQ              reduce using rule 59 (atom -> LBRACKET arg_list_opt RBRACKET .)
    NEQ             reduce using rule 59 (atom -> LBRACKET arg_list_opt RBRACKET .)
    LT              reduce using rule 59 (atom -> LBRACKET arg_list_opt RBRACKET .)
    GT              reduce using rule 59 (atom -> LBRACKET arg_list_opt RBRACKET .)
    LE              reduce using rule 59 (atom -> LBRACKET arg_list_opt RBRACKET .)
    GE              reduce using rule 59 (atom -> LBRACKET arg_list_opt RBRACKET .)
    PLUS            reduce using rule 59 (atom -> LBRACKET arg_list_opt RBRACKET .)
    MINUS           reduce using rule 59 (atom -> LBRACKET arg_list_opt RBRACKET .)
    AND             reduce using rule 59 (atom -> LBRACKET arg_list_opt RBRACKET .)
    OR              reduce using rule 59 (atom -> LBRACKET arg_list_opt RBRACKET .)
    SEMICOLON       reduce using rule 59 (atom -> LBRACKET arg_list_opt RBRACKET .)
    RPAREN          reduce using rule 59 (atom -> LBRACKET arg_list_opt RBRACKET .)
    COMMA           reduce using rule 59 (atom -> LBRACKET arg_list_opt RBRACKET .)
    RBRACKET        reduce using rule 59 (atom -> LBRACKET arg_list_opt RBRACKET .)


state 86

    (58) arg_list -> arg_list COMMA . expression
    (22) expression -> . or_expr
    (23) or_expr -> . or_expr OR and_expr
    (24) or_expr -> . and_expr
    (25) and_expr -> . and_expr AND not_expr
    (26) and_expr -> . not_expr
    (27) not_expr -> . NOT not_expr
    (28) not_expr -> . comparison
    (29) comparison -> . arith_expr EQ arith_expr
    (30) comparison -> . arith_expr NEQ arith_expr
    (31) comparison -> . arith_expr LT arith_expr
    (32) comparison -> . arith_expr GT arith_expr
    (33) comparison -> . arith_expr LE arith_expr
    (34) comparison -> . arith_expr GE arith_expr
    (35) comparison -> . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    NOT             shift and go to state 19
    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    expression                     shift and go to state 95
    or_expr                        shift and go to state 16
    and_expr                       shift and go to state 17
    not_expr                       shift and go to state 18
    comparison                     shift and go to state 20
    arith_expr                     shift and go to state 21
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 87

    (54) atom -> IDENT LPAREN arg_list_opt RPAREN .

    TIMES           reduce using rule 54 (atom -> IDENT LPAREN arg_list_opt RPAREN .)
    DIVIDE          reduce using rule 54 (atom -> IDENT LPAREN arg_list_opt RPAREN .)
    MOD             reduce using rule 54 (atom -> IDENT LPAREN arg_list_opt RPAREN .)
    EQ              reduce using rule 54 (atom -> IDENT LPAREN arg_list_opt RPAREN .)
    NEQ             reduce using rule 54 (atom -> IDENT LPAREN arg_list_opt RPAREN .)
    LT              reduce using rule 54 (atom -> IDENT LPAREN arg_list_opt RPAREN .)
    GT              reduce using rule 54 (atom -> IDENT LPAREN arg_list_opt RPAREN .)
    LE              reduce using rule 54 (atom -> IDENT LPAREN arg_list_opt RPAREN .)
    GE              reduce using rule 54 (atom -> IDENT LPAREN arg_list_opt RPAREN .)
    PLUS            reduce using rule 54 (atom -> IDENT LPAREN arg_list_opt RPAREN .)
    MINUS           reduce using rule 54 (atom -> IDENT LPAREN arg_list_opt RPAREN .)
    AND             reduce using rule 54 (atom -> IDENT LPAREN arg_list_opt RPAREN .)
    OR              reduce using rule 54 (atom -> IDENT LPAREN arg_list_opt RPAREN .)
    SEMICOLON       reduce using rule 54 (atom -> IDENT LPAREN arg_list_opt RPAREN .)
    RPAREN          reduce using rule 54 (atom -> IDENT LPAREN arg_list_opt RPAREN .)
    COMMA           reduce using rule 54 (atom -> IDENT LPAREN arg_list_opt RPAREN .)
    RBRACKET        reduce using rule 54 (atom -> IDENT LPAREN arg_list_opt RPAREN .)


state 88

    (11) simple_stmt -> PRINT LPAREN arg_list_opt RPAREN .

    SEMICOLON       reduce using rule 11 (simple_stmt -> PRINT LPAREN arg_list_opt RPAREN .)


state 89

    (12) block_stmt -> IF LPAREN expression RPAREN . block
    (13) block_stmt -> IF LPAREN expression RPAREN . block ELSE block
    (21) block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 97

    block                          shift and go to state 96

state 90

    (14) block_stmt -> WHILE LPAREN expression RPAREN . block
    (21) block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 97

    block                          shift and go to state 98

state 91

    (15) block_stmt -> FOR LPAREN IDENT IN . expression RPAREN block
    (22) expression -> . or_expr
    (23) or_expr -> . or_expr OR and_expr
    (24) or_expr -> . and_expr
    (25) and_expr -> . and_expr AND not_expr
    (26) and_expr -> . not_expr
    (27) not_expr -> . NOT not_expr
    (28) not_expr -> . comparison
    (29) comparison -> . arith_expr EQ arith_expr
    (30) comparison -> . arith_expr NEQ arith_expr
    (31) comparison -> . arith_expr LT arith_expr
    (32) comparison -> . arith_expr GT arith_expr
    (33) comparison -> . arith_expr LE arith_expr
    (34) comparison -> . arith_expr GE arith_expr
    (35) comparison -> . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    NOT             shift and go to state 19
    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    IDENT           shift and go to state 38
    LBRACKET        shift and go to state 33

    expression                     shift and go to state 99
    or_expr                        shift and go to state 16
    and_expr                       shift and go to state 17
    not_expr                       shift and go to state 18
    comparison                     shift and go to state 20
    arith_expr                     shift and go to state 21
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 92

    (19) param_list -> IDENT .

    COMMA           reduce using rule 19 (param_list -> IDENT .)
    RPAREN          reduce using rule 19 (param_list -> IDENT .)


state 93

    (16) block_stmt -> DEF IDENT LPAREN param_list_opt . RPAREN block

    RPAREN          shift and go to state 100


state 94

    (18) param_list_opt -> param_list .
    (20) param_list -> param_list . COMMA IDENT

    RPAREN          reduce using rule 18 (param_list_opt -> param_list .)
    COMMA           shift and go to state 101


state 95

    (58) arg_list -> arg_list COMMA expression .

    COMMA           reduce using rule 58 (arg_list -> arg_list COMMA expression .)
    RBRACKET        reduce using rule 58 (arg_list -> arg_list COMMA expression .)
    RPAREN          reduce using rule 58 (arg_list -> arg_list COMMA expression .)


state 96

    (12) block_stmt -> IF LPAREN expression RPAREN block .
    (13) block_stmt -> IF LPAREN expression RPAREN block . ELSE block

    IDENT           reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    RETURN          reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    PASS            reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    PRINT           reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    IF              reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    WHILE           reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    FOR             reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    DEF             reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    NOT             reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    PLUS            reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    MINUS           reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    LPAREN          reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    INT             reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    FLOAT           reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    STRING          reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    TRUE            reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    FALSE           reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    NONE            reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    LBRACKET        reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    $end            reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    RBRACE          reduce using rule 12 (block_stmt -> IF LPAREN expression RPAREN block .)
    ELSE            shift and go to state 102


state 97

    (21) block -> LBRACE . stmt_list RBRACE
    (2) stmt_list -> .
    (3) stmt_list -> . stmt_list statement

    RBRACE          reduce using rule 2 (stmt_list -> .)
    IDENT           reduce using rule 2 (stmt_list -> .)
    RETURN          reduce using rule 2 (stmt_list -> .)
    PASS            reduce using rule 2 (stmt_list -> .)
    PRINT           reduce using rule 2 (stmt_list -> .)
    IF              reduce using rule 2 (stmt_list -> .)
    WHILE           reduce using rule 2 (stmt_list -> .)
    FOR             reduce using rule 2 (stmt_list -> .)
    DEF             reduce using rule 2 (stmt_list -> .)
    NOT             reduce using rule 2 (stmt_list -> .)
    PLUS            reduce using rule 2 (stmt_list -> .)
    MINUS           reduce using rule 2 (stmt_list -> .)
    LPAREN          reduce using rule 2 (stmt_list -> .)
    INT             reduce using rule 2 (stmt_list -> .)
    FLOAT           reduce using rule 2 (stmt_list -> .)
    STRING          reduce using rule 2 (stmt_list -> .)
    TRUE            reduce using rule 2 (stmt_list -> .)
    FALSE           reduce using rule 2 (stmt_list -> .)
    NONE            reduce using rule 2 (stmt_list -> .)
    LBRACKET        reduce using rule 2 (stmt_list -> .)

    stmt_list                      shift and go to state 103

state 98

    (14) block_stmt -> WHILE LPAREN expression RPAREN block .

    IDENT           reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    RETURN          reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    PASS            reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    PRINT           reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    IF              reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    WHILE           reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    FOR             reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    DEF             reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    NOT             reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    PLUS            reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    MINUS           reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    LPAREN          reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    INT             reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    FLOAT           reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    STRING          reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    TRUE            reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    FALSE           reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    NONE            reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    LBRACKET        reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    $end            reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)
    RBRACE          reduce using rule 14 (block_stmt -> WHILE LPAREN expression RPAREN block .)


state 99

    (15) block_stmt -> FOR LPAREN IDENT IN expression . RPAREN block

    RPAREN          shift and go to state 104


state 100

    (16) block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN . block
    (21) block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 97

    block                          shift and go to state 105

state 101

    (20) param_list -> param_list COMMA . IDENT

    IDENT           shift and go to state 106


state 102

    (13) block_stmt -> IF LPAREN expression RPAREN block ELSE . block
    (21) block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 97

    block                          shift and go to state 107

state 103

    (21) block -> LBRACE stmt_list . RBRACE
    (3) stmt_list -> stmt_list . statement
    (4) statement -> . simple_stmt SEMICOLON
    (5) statement -> . block_stmt
    (6) simple_stmt -> . expression
    (7) simple_stmt -> . IDENT ASSIGN expression
    (8) simple_stmt -> . RETURN expression
    (9) simple_stmt -> . RETURN
    (10) simple_stmt -> . PASS
    (11) simple_stmt -> . PRINT LPAREN arg_list_opt RPAREN
    (12) block_stmt -> . IF LPAREN expression RPAREN block
    (13) block_stmt -> . IF LPAREN expression RPAREN block ELSE block
    (14) block_stmt -> . WHILE LPAREN expression RPAREN block
    (15) block_stmt -> . FOR LPAREN IDENT IN expression RPAREN block
    (16) block_stmt -> . DEF IDENT LPAREN param_list_opt RPAREN block
    (22) expression -> . or_expr
    (23) or_expr -> . or_expr OR and_expr
    (24) or_expr -> . and_expr
    (25) and_expr -> . and_expr AND not_expr
    (26) and_expr -> . not_expr
    (27) not_expr -> . NOT not_expr
    (28) not_expr -> . comparison
    (29) comparison -> . arith_expr EQ arith_expr
    (30) comparison -> . arith_expr NEQ arith_expr
    (31) comparison -> . arith_expr LT arith_expr
    (32) comparison -> . arith_expr GT arith_expr
    (33) comparison -> . arith_expr LE arith_expr
    (34) comparison -> . arith_expr GE arith_expr
    (35) comparison -> . arith_expr
    (36) arith_expr -> . arith_expr PLUS term
    (37) arith_expr -> . arith_expr MINUS term
    (38) arith_expr -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . term MOD factor
    (42) term -> . factor
    (43) factor -> . PLUS factor
    (44) factor -> . MINUS factor
    (45) factor -> . atom
    (46) atom -> . LPAREN expression RPAREN
    (47) atom -> . INT
    (48) atom -> . FLOAT
    (49) atom -> . STRING
    (50) atom -> . TRUE
    (51) atom -> . FALSE
    (52) atom -> . NONE
    (53) atom -> . IDENT
    (54) atom -> . IDENT LPAREN arg_list_opt RPAREN
    (59) atom -> . LBRACKET arg_list_opt RBRACKET

    RBRACE          shift and go to state 108
    IDENT           shift and go to state 7
    RETURN          shift and go to state 8
    PASS            shift and go to state 9
    PRINT           shift and go to state 10
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    DEF             shift and go to state 15
    NOT             shift and go to state 19
    PLUS            shift and go to state 22
    MINUS           shift and go to state 24
    LPAREN          shift and go to state 11
    INT             shift and go to state 27
    FLOAT           shift and go to state 28
    STRING          shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    NONE            shift and go to state 32
    LBRACKET        shift and go to state 33

    statement                      shift and go to state 3
    simple_stmt                    shift and go to state 4
    block_stmt                     shift and go to state 5
    expression                     shift and go to state 6
    or_expr                        shift and go to state 16
    and_expr                       shift and go to state 17
    not_expr                       shift and go to state 18
    comparison                     shift and go to state 20
    arith_expr                     shift and go to state 21
    term                           shift and go to state 23
    factor                         shift and go to state 25
    atom                           shift and go to state 26

state 104

    (15) block_stmt -> FOR LPAREN IDENT IN expression RPAREN . block
    (21) block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 97

    block                          shift and go to state 109

state 105

    (16) block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .

    IDENT           reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    RETURN          reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    PASS            reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    PRINT           reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    IF              reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    WHILE           reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    FOR             reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    DEF             reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    NOT             reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    PLUS            reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    MINUS           reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    LPAREN          reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    INT             reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    FLOAT           reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    STRING          reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    TRUE            reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    FALSE           reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    NONE            reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    LBRACKET        reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    $end            reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)
    RBRACE          reduce using rule 16 (block_stmt -> DEF IDENT LPAREN param_list_opt RPAREN block .)


state 106

    (20) param_list -> param_list COMMA IDENT .

    COMMA           reduce using rule 20 (param_list -> param_list COMMA IDENT .)
    RPAREN          reduce using rule 20 (param_list -> param_list COMMA IDENT .)


state 107

    (13) block_stmt -> IF LPAREN expression RPAREN block ELSE block .

    IDENT           reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    RETURN          reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    PASS            reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    PRINT           reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    IF              reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    WHILE           reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    FOR             reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    DEF             reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    NOT             reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    PLUS            reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    MINUS           reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    LPAREN          reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    INT             reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    FLOAT           reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    STRING          reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    TRUE            reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    FALSE           reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    NONE            reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    LBRACKET        reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    $end            reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)
    RBRACE          reduce using rule 13 (block_stmt -> IF LPAREN expression RPAREN block ELSE block .)


state 108

    (21) block -> LBRACE stmt_list RBRACE .

    ELSE            reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    IDENT           reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    RETURN          reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    PASS            reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    PRINT           reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    IF              reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    WHILE           reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    FOR             reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    DEF             reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    NOT             reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    PLUS            reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    MINUS           reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    LPAREN          reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    INT             reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    STRING          reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    TRUE            reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    FALSE           reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    NONE            reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    LBRACKET        reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    $end            reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)
    RBRACE          reduce using rule 21 (block -> LBRACE stmt_list RBRACE .)


state 109

    (15) block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .

    IDENT           reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    RETURN          reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    PASS            reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    PRINT           reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    IF              reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    WHILE           reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    FOR             reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    DEF             reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    NOT             reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    PLUS            reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    MINUS           reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    LPAREN          reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    INT             reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    FLOAT           reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    STRING          reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    TRUE            reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    FALSE           reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    NONE            reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    LBRACKET        reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    $end            reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)
    RBRACE          reduce using rule 15 (block_stmt -> FOR LPAREN IDENT IN expression RPAREN block .)


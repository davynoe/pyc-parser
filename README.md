# PyC

A full compiler for a custom language that pairs Python-like dynamic semantics with C-style syntax (curly braces, semicolons). It spans lexing through execution on a stack-based virtual machine (VM), illustrating the core compiler stages: lexing, parsing, AST, IR, bytecode generation, and VM execution.

---

## Language Features

### Data Types
- Integers
- Floats  
- Strings (single or double quoted)
- Booleans (True, False)
- None
- Lists

### Operators
- Arithmetic: `+`, `-`, `*`, `/`, `%`
- Comparison: `==`, `!=`, `<`, `>`, `<=`, `>=`
- Logical: `and`, `or`, `not`
- Unary: `-`, `+`, `not`

### Statements
- Variable assignment: `x = 5;`
- If/else: `if (x > 5) { ... } else { ... }`
- While loops: `while (x > 0) { ... }`
- For loops: `for (i in range) { ... }`
- Function definition: `def func(a, b) { ... }`
- Return: `return value;`
- Print: `print(x, y, z);`
- Pass: `pass;`

### C-like Syntax
- Semicolons terminate statements
- Curly braces for blocks
- Parentheses for function calls and conditions

## üèó Architecture Overview

The compiler follows a classic multi-stage pipeline, targeting custom bytecode executed by a dedicated VM.

```
Source Code (.pc)
	‚îÇ
	‚ñº
[1. Lexical Analysis] ‚îÄ‚îÄ> Token Stream
	‚îÇ
	‚ñº
[2. Parsing] ‚îÄ‚îÄ> Abstract Syntax Tree (AST)
	‚îÇ
	‚ñº
[3. Semantic Analysis] ‚îÄ‚îÄ> Intermediate Representation (IR)
	‚îÇ
	‚ñº
[4. Code Generation] ‚îÄ‚îÄ> Custom Bytecode
	‚îÇ
	‚ñº
[5. Virtual Machine] ‚îÄ‚îÄ> Execution (Output)
```

**Tooling choices**
- Lexer: PLY (Lex) rules with regex and reserved-word dispatch
- Parser: PLY (Yacc) LALR(1) parser with precedence rules to remove ambiguity
- Target: Custom stack-based bytecode executed on an in-house VM
- Language flavor: Python-like semantics (dynamic types, functions, truthiness) with C-style syntax (braces + semicolons)

---

## 1. Syntax & Lexical Analysis (Lexer)

The lexer converts raw source into tokens.

- Tool: PLY (Python Lex-Yacc) with regex rules
- Identifier rules: start with a letter
- Reserved keywords: `if`, `while`, `def`, etc.
- Semicolons are mandatory statement terminators
- Dynamic typing: `int`, `float`, `string`
- Whitespace: insignificant except inside strings; newlines are not statement terminators
- Comments: `# ...` to end of line

**Valid vs Invalid (Lexer)**

| Input             | Status | Tokens / Error                                 |
| ----------------- | ------ | ---------------------------------------------- |
| `x = 10;`         | ‚úÖ     | IDENT(x), ASSIGN, INT(10), SEMICOLON           |
| `float_val = 3.14;` | ‚úÖ   | IDENT, ASSIGN, FLOAT(3.14), SEMICOLON          |
| `money = 100$;`   | ‚ùå     | Lexer Error: Illegal character `$`             |
| `if(x)`           | ‚úÖ     | IF, LPAREN, IDENT, RPAREN                      |

---

## 2. Grammar & Parsing (AST)

Parses tokens into an Abstract Syntax Tree.

- Context-Free Grammar (BNF-style)
- Parser: LALR(1) generated by PLY Yacc
- Operator precedence support to resolve shift/reduce conflicts
- AST nodes for operations, literals, identifiers, control flow, functions, lists

**Core grammar snippets (simplified)**

```
program     : stmt_list
stmt_list   : /* empty */ | stmt_list statement
statement   : simple_stmt SEMICOLON | block_stmt

simple_stmt : expression
			| IDENT ASSIGN expression
			| RETURN expression
			| RETURN
			| PASS
			| PRINT LPAREN arg_list_opt RPAREN

block_stmt  : IF LPAREN expression RPAREN block
			| IF LPAREN expression RPAREN block ELSE block
			| WHILE LPAREN expression RPAREN block
			| FOR LPAREN IDENT IN expression RPAREN block
			| DEF IDENT LPAREN param_list_opt RPAREN block

block       : LBRACE stmt_list RBRACE
```

**Valid vs Invalid (Parser)**

| Input                       | Status | Explanation              |
| --------------------------- | ------ | ------------------------ |
| `if (x > 5) { print(x); }` | ‚úÖ     | Generates `If` node      |
| `x = 5 + 3 * 2;`           | ‚úÖ     | Correct precedence       |
| `if x > 5 { print(x) }`    | ‚ùå     | Missing parentheses      |
| `x = 10`                   | ‚ùå     | Missing semicolon        |

---

## 3. Semantic Analysis & IR Generation

Transforms the AST into linear IR and checks semantics.

- Assembly-like IR: `LOAD`, `STORE`, `ADD`, ...
- Symbol tables for scope tracking
- Control flow lowered to jumps and labels
- Function handling: parameters defined in function scope; each `def` becomes a separate IR list
- Lists: lowered via `BUILD_LIST` with element count
- For-loops: lowered to `SETUP_LOOP`, `FOR_ITER`, and jump labels

**Valid vs Invalid (Semantic)**

| Input                      | Status | Result         |
| -------------------------- | ------ | -------------- |
| `x = 5; print(x);`        | ‚úÖ     | Valid IR       |
| `def f(){ y=1; } print(y);` | ‚ùå   | Scope error    |
| `while(x<5){...}`         | ‚úÖ     | Loop IR        |

---

## 4. Code Generation & VM Target

IR is converted to compact numeric bytecode.

**Bytecode Characteristics**
- Stack-based VM
- Encoded as `[Opcode, Operand, ...]`
- Constant pool and name pool
- Functions stored as separate code arrays with parameter lists

**VM Architecture**
- Stack operations
- Isolated call frames for functions (bindings for parameters; shallow copy of enclosing vars)
- Basic loop support via iterator state (`SETUP_LOOP`/`FOR_ITER`)
- Errors: undefined variable/function raise at runtime

---

## üöÄ End-to-End Execution Trace

**Source**
```pc
x = 5 + 3;
print(x);
```

**Tokens**
```
LexToken(IDENT,'x',1,0)
LexToken(ASSIGN,'=',1,2)
LexToken(INT,5,1,4)
LexToken(PLUS,'+',1,6)
LexToken(INT,3,1,8)
LexToken(SEMICOLON,';',1,9)
LexToken(PRINT,'print',2,11)
LexToken(LPAREN,'(',2,16)
LexToken(IDENT,'x',2,17)
LexToken(RPAREN,')',2,18)
LexToken(SEMICOLON,';',2,19)
```

**AST**
```
Program
|-- Assign x
|   -- Binary '+'
|       -- Literal 5
|       -- Literal 3
-- Print
    -- Var x
```

**IR**
```
LOAD_CONST 5
LOAD_CONST 3
ADD
STORE x
LOAD x
PRINT 1
```

**Bytecode (Disassembly)**
```
Constants: [5, 3]
Names: ['x']
Functions: []

Disassembly:
   0  LOAD_CONST           0 (= 5)
   2  LOAD_CONST           1 (= 3)
   4  ADD
   5  STORE                0 (= x)
   7  LOAD                 0 (= x)
   9  PRINT                [1]
```

**Output**
```
8
```

**Quick mental model**
- Evaluation order is left-to-right; binary ops push operands then apply
- Names resolve at runtime from the current frame (dynamic, no type checks)
- Print pops arguments then writes to stdout

---

## üõ† Installation & Usage

**Requirements**
- Python 3.8+
- ply

```bash
pip install ply
```

**Run**

```bash
python compiler.py script.pc
python compiler.py script.pc -v
```

**Tests**

```bash
python compiler.py tests/valid_arithmetic.pc
```